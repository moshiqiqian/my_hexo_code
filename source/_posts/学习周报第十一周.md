---
title: 学习周报第十一周
tags:
  - 人工智能
categories:
  - 周报
  
description: 并行计算实验室学习周报
abbrlink: 1ccd9381
date: 2025-09-08 10:42:10
---
### 代码

~~~python
#********************************************
# 多维度 QDA 收敛曲线对比（中文可视化）
#********************************************
import numpy as np
import time
import matplotlib.pyplot as plt


# --- 解决中文显示和负号问题 ---
plt.rcParams['font.sans-serif'] = ['Microsoft YaHei']
plt.rcParams['axes.unicode_minus'] = False
# --------------------------------

# --- 目标函数 ---
def func_double_well(matrix_y):
    y = 0
    l, k, h = 3.0, 0.5, 20.0
    for i in matrix_y:
        y += h * pow((pow(i, 2) - pow(l, 2)), 2) / pow(l, 4) + k * i
    return y

def func_rastrigin(matrix_y):
    y = 10 * len(matrix_y)
    y += np.sum(matrix_y**2 - 10 * np.cos(2 * np.pi * matrix_y))
    return y

def func_griewank(matrix_y):
    a, b, y = 0, 1, 0
    index = 1
    for i in matrix_y:
        a = a + i * i
        b = b * np.cos(i / np.sqrt(index))
        index += 1
    y = 1 + 1 / 4000 * a - b
    return y

# --- 辅助函数：最大/最小 walker（原始版本） ---
def max_min_id(matrix, flag, func_to_use):
    if matrix.shape[1] == 0:
        return -1
    walker_id = 0
    temp = func_to_use(matrix[:, 0])
    for j in range(matrix.shape[1] - 1):
        if temp < func_to_use(matrix[:, j + 1]) and flag == 0:  # max condition
            walker_id = j + 1
            temp = func_to_use(matrix[:, j + 1])
        if temp > func_to_use(matrix[:, j + 1]) and flag == 1:  # min condition
            walker_id = j + 1
            temp = func_to_use(matrix[:, j + 1])
    return walker_id

# --- 辅助函数：均值替换（兼容原始 max_min_id） ---
def mid_exchange(matrix, func_to_use):
    mid_walker = np.mean(matrix, axis=1)
    worst_id = max_min_id(matrix, 0, func_to_use)
    matrix[:, worst_id] = mid_walker
    return matrix

# --- 标准 QDA 算法（按迭代次数记录） ---
def qda_original_record(dim, walker_n, func_to_use, max_total_iter):
    acc = 1e-6
    ite_times = 0
    begin, end = -6, 6
    scale = end - begin
    a = np.random.uniform(begin, end, (dim, walker_n))
    b = np.zeros((dim, walker_n))
    ite_flag = True
    convergence_data = []

    while scale > acc and ite_times < max_total_iter:
        while ite_flag and ite_times < max_total_iter:
            ite_times += 1
            for j in range(walker_n):
                for i in range(dim):
                    b[i, j] = np.random.normal(a[i, j], scale)
                    while not (begin <= b[i, j] <= end):
                        b[i, j] = np.random.normal(a[i, j], scale)
                
                if func_to_use(b[:, j]) > func_to_use(a[:, j]):
                    b[:, j] = a[:, j]

            mid_exchange(b, func_to_use)
            a[:, :] = b[:, :]
            
            min_val = func_to_use(a[:, max_min_id(a, 1, func_to_use)])
            convergence_data.append(min_val)
            
            ite_flag = False
            for i in range(dim):
                if np.var(a[i, :]) > pow(scale, 2):
                    ite_flag = True
        
        scale /= 2
        ite_flag = True
    
    return convergence_data

# --- 差解接收 QDA 算法（按迭代次数记录） ---
def qda_diff_accept_record(dim, walker_n, func_to_use, max_total_iter):
    acc = 1e-6
    ite_times = 0
    begin, end = -6, 6
    scale = end - begin
    a = np.random.uniform(begin, end, (dim, walker_n))
    b = np.zeros((dim, walker_n))
    ite_flag = True
    convergence_data = []

    while scale > acc and ite_times < max_total_iter:
        while ite_flag and ite_times < max_total_iter:
            ite_times += 1
            for j in range(walker_n):
                old_fitness = func_to_use(a[:, j])
                for i in range(dim):
                    b[i, j] = np.random.normal(a[i, j], scale)
                    while not (begin <= b[i, j] <= end):
                        b[i, j] = np.random.normal(a[i, j], scale)
                new_fitness = func_to_use(b[:, j])
                
                if new_fitness > old_fitness:
                    acceptance_prob = 1.0 / (ite_times)
                    if np.random.rand() >= acceptance_prob:
                        b[:, j] = a[:, j]
            
            mid_exchange(b, func_to_use)
            a[:, :] = b[:, :]
            
            min_val = func_to_use(a[:, max_min_id(a, 1, func_to_use)])
            convergence_data.append(min_val)

            ite_flag = False
            for i in range(dim):
                if np.var(a[i, :]) > pow(scale, 2):
                    ite_flag = True
        
        scale /= 2
        ite_flag = True
    
    return convergence_data

# --- 绘制多维度对比 ---
def plot_multi_dim(dim_list, walker_n, func_to_use, func_name, num_runs, max_total_iter):
    print(f"--- QDA 算法对比测试 ---")
    print(f"目标函数: {func_name}")
    print(f"种群数: {walker_n}")
    print(f"每组运行次数: {num_runs}")
    print(f"最大迭代次数: {max_total_iter}")
    for dim in dim_list:
        print(f"--- 维度: {dim}D ---")
    print("-" * 25)

    n = len(dim_list)
    rows = (n + 1) // 2
    plt.figure(figsize=(15, 6 * rows))
    
    for i, dim in enumerate(dim_list):
        start_time = time.time()
        
        standard_runs = [qda_original_record(dim, walker_n, func_to_use, max_total_iter) for _ in range(num_runs)]
        optimized_runs = [qda_diff_accept_record(dim, walker_n, func_to_use, max_total_iter) for _ in range(num_runs)]
        
        end_time = time.time()
        print(f"维度 {dim}D 测试完成，耗时: {end_time - start_time:.2f} 秒")
        
        # 统一数据长度
        max_len = max_total_iter
        standard_padded = np.array([run + [run[-1]] * (max_len - len(run)) for run in standard_runs])
        optimized_padded = np.array([run + [run[-1]] * (max_len - len(run)) for run in optimized_runs])

        if len(standard_padded) == 0 or len(optimized_padded) == 0:
            print(f"警告：维度 {dim}D 的收敛数据点过少，无法绘制有意义的曲线。")
            continue
        
        avg_orig = np.mean(standard_padded, axis=0)
        avg_diff = np.mean(optimized_padded, axis=0)

        x_axis = np.arange(len(avg_orig))

        ax = plt.subplot(rows, 2, i + 1)
        ax.plot(x_axis, avg_orig, label="标准版", color='blue', linewidth=2)
        ax.plot(x_axis, avg_diff, '--', label="优化版", color='red', linewidth=2)
        
        ax.set_title(f"维度: {dim}D", fontsize=14)
        ax.set_xlabel("迭代次数", fontsize=12)
        ax.set_ylabel("平均最优函数值", fontsize=12)
        
        all_values = np.concatenate((avg_orig, avg_diff))
        if np.all(all_values > 0):
            ax.set_yscale('log')
        
        ax.grid(True, linestyle=':', alpha=0.6)
        ax.legend(loc='upper right', fontsize=10)
        
    plt.suptitle(f"QDA 算法收敛曲线对比 ({func_name})", fontsize=20)
    plt.tight_layout(rect=[0, 0, 1, 0.96])
    plt.show()
             
# --- 示例调用 ---
if __name__ == "__main__":
    test_dimensions = [2, 5, 10, 20, 30]
    test_walker_n = 50
    test_func = func_rastrigin
    test_func_name = "rastrigin"
    num_runs = 10
    max_total_iter = 100000

    plot_multi_dim(test_dimensions, test_walker_n, test_func, test_func_name, num_runs, max_total_iter)
~~~





### 代码测试

~~~~
--- QDA 算法对比测试 ---
目标函数: rastrigin
种群数: 50
每组运行次数: 10
最大迭代次数: 100000
--- 维度: 2D ---
--- 维度: 5D ---
--- 维度: 10D ---
--- 维度: 20D ---
--- 维度: 30D ---
-------------------------
维度 2D 测试完成，耗时: 12.87 秒
维度 5D 测试完成，耗时: 356.66 秒
维度 10D 测试完成，耗时: 1652.73 秒
维度 20D 测试完成，耗时: 3456.55 秒
维度 30D 测试完成，耗时: 4136.02 秒
~~~~

![image](https://moshiqiqian.github.io/picx-images-hosting/周报/image.2a5fu06fk6.webp)

![image](https://moshiqiqian.github.io/picx-images-hosting/周报/image.wiwpyvlx2.webp)

~~~
--- QDA 算法对比测试 ---
目标函数: double_well
种群数: 50
每组运行次数: 10
最大迭代次数: 100000
--- 维度: 2D ---
--- 维度: 5D ---
--- 维度: 10D ---
--- 维度: 20D ---
--- 维度: 30D ---
-------------------------
维度 2D 测试完成，耗时: 4.90 秒
维度 5D 测试完成，耗时: 97.32 秒
维度 10D 测试完成，耗时: 2085.30 秒
维度 20D 测试完成，耗时: 6700.07 秒
维度 30D 测试完成，耗时: 13188.60 秒
~~~

![image](https://moshiqiqian.github.io/picx-images-hosting/周报/image.4cl8i25g6v.webp)

![image](https://moshiqiqian.github.io/picx-images-hosting/周报/image.51ei22t95f.webp)

~~~
--- QDA 算法对比测试 ---
目标函数: griewank
种群数: 50
每组运行次数: 10
最大迭代次数: 10000
--- 维度: 2D ---
--- 维度: 5D ---
--- 维度: 10D ---
--- 维度: 20D ---
--- 维度: 30D ---
-------------------------
维度 2D 测试完成，耗时: 46.63 秒
维度 5D 测试完成，耗时: 26.75 秒
维度 10D 测试完成，耗时: 112.92 秒
维度 20D 测试完成，耗时: 542.88 秒
维度 30D 测试完成，耗时: 1241.56 秒
~~~

![image](https://moshiqiqian.github.io/picx-images-hosting/周报/image.6bhf8ebkzm.webp)

![image](https://moshiqiqian.github.io/picx-images-hosting/周报/image.7snka5fv9r.webp)